// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package ioc

import (
	"ai-gateway/config"
	"ai-gateway/internal/api/http"
	"ai-gateway/internal/api/http/handler"
	"ai-gateway/internal/ioc"
	"ai-gateway/internal/pkg/logger"
	"ai-gateway/internal/pkg/ratelimit"
	"ai-gateway/internal/repository"
	"ai-gateway/internal/repository/cache"
	"ai-gateway/internal/repository/dao"
	"ai-gateway/internal/service/apikey"
	"ai-gateway/internal/service/auth"
	"ai-gateway/internal/service/chat"
	"ai-gateway/internal/service/gateway"
	"ai-gateway/internal/service/loadbalance"
	"ai-gateway/internal/service/modelrate"
	"ai-gateway/internal/service/provider"
	"ai-gateway/internal/service/routingrule"
	"ai-gateway/internal/service/usage"
	"ai-gateway/internal/service/user"
	"ai-gateway/internal/service/wallet"
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"
	"time"
)

// Injectors from wire.go:

// InitApp 初始化应用（Wire 生成实现位于 wire_gen.go）。
func InitApp(cfg *config.Config) (*App, error) {
	logger := provideLogger(cfg)
	db, err := provideDB(cfg, logger)
	if err != nil {
		return nil, err
	}
	providerDAO := dao.NewGormProviderDAO(db)
	cmdable, err := provideRedis(cfg, logger)
	if err != nil {
		return nil, err
	}
	providerCache := provideProviderCache(cmdable)
	providerRepository := repository.NewProviderRepository(providerDAO, providerCache)
	routingRuleDAO := dao.NewGormRoutingRuleDAO(db)
	routingRuleCache := provideRoutingRuleCache(cmdable)
	routingRuleRepository := repository.NewRoutingRuleRepository(routingRuleDAO, routingRuleCache)
	loadBalanceDAO := dao.NewGormLoadBalanceDAO(db)
	loadBalanceRepository := repository.NewLoadBalanceRepository(loadBalanceDAO)
	gatewayService := gateway.NewGatewayService(providerRepository, routingRuleRepository, loadBalanceRepository, logger)
	walletDAO := dao.NewGormWalletDAO(db)
	walletRepository := repository.NewWalletRepository(walletDAO)
	modelRateDAO := dao.NewGormModelRateDAO(db)
	modelRateCache := provideModelRateCache(cmdable)
	modelRateRepository := repository.NewModelRateRepository(modelRateDAO, modelRateCache)
	service := modelrate.NewService(modelRateRepository, logger)
	walletService := wallet.NewService(walletRepository, service, logger)
	usageLogDAO := dao.NewGormUsageLogDAO(db)
	usageLogRepository := repository.NewUsageLogRepository(usageLogDAO)
	usageService := usage.NewService(usageLogRepository, walletService, logger)
	apiKeyDAO := dao.NewGormAPIKeyDAO(db)
	apiKeyCache := provideAPIKeyCache(cmdable)
	apiKeyRepository := repository.NewAPIKeyRepository(apiKeyDAO, apiKeyCache)
	apikeyService := apikey.NewService(apiKeyRepository, logger)
	chatService := chat.NewService(gatewayService, walletService, usageService, apikeyService, service, logger)
	openAIHandler := handler.NewOpenAIHandler(gatewayService, chatService, logger)
	anthropicHandler := handler.NewAnthropicHandler(chatService, logger)
	providerService := provider.NewService(providerRepository, logger)
	routingruleService := routingrule.NewService(routingRuleRepository, logger)
	loadbalanceService := loadbalance.NewService(loadBalanceRepository, logger)
	userDAO := dao.NewGormUserDAO(db)
	userRepository := repository.NewUserRepository(userDAO)
	userService := user.NewService(userRepository, usageLogRepository, logger)
	adminHandler := handler.NewAdminHandler(providerService, routingruleService, loadbalanceService, apikeyService, userService, usageService, gatewayService, service, walletService, logger)
	authService := provideAuthService(cfg)
	authHandler := handler.NewAuthHandler(userService, authService, logger)
	userHandler := handler.NewUserHandler(userService, apikeyService, walletService, gatewayService, service, logger)
	healthHandler := handler.NewHealthHandler(db, cmdable, logger)
	limiter := provideLimiter(cfg, cmdable)
	authConfig := provideAuthConfig(cfg)
	server := http.NewServer(openAIHandler, anthropicHandler, adminHandler, authHandler, userHandler, healthHandler, authService, apikeyService, limiter, authConfig, logger)
	app := &App{
		Logger:     logger,
		HTTPServer: server,
	}
	return app, nil
}

// wire.go:

// App 应用依赖集合。
type App struct {
	Logger     logger.Logger
	HTTPServer *http.Server
}

func provideLogger(cfg *config.Config) logger.Logger {
	return ioc.InitLogger(cfg)
}

func provideDB(cfg *config.Config, l logger.Logger) (*gorm.DB, error) {
	return ioc.InitDB(cfg, l)
}

func provideRedis(cfg *config.Config, l logger.Logger) (redis.Cmdable, error) {
	return ioc.InitRedis(cfg, l)
}

func provideLimiter(cfg *config.Config, rdb redis.Cmdable) ratelimit.Limiter {
	if !cfg.RateLimit.Enabled || rdb == nil {
		return nil
	}
	window := cfg.RateLimit.Window
	if window <= 0 {
		window = time.Minute
	}
	rate := cfg.RateLimit.Rate
	if rate <= 0 {
		rate = 100
	}
	return ratelimit.NewRedisSlidingWindowLimiter(rdb, window, rate)
}

func provideAuthConfig(cfg *config.Config) config.AuthConfig {
	return cfg.Auth
}

func provideAuthService(cfg *config.Config) *auth.AuthService {
	secret := cfg.Auth.JWTSecret
	if secret == "" {
		secret = "ai-gateway-default-secret-change-in-production"
	}
	return auth.NewAuthService(secret, 24*time.Hour)
}

func provideAPIKeyCache(rdb redis.Cmdable) cache.APIKeyCache {
	if rdb == nil {
		return nil
	}
	return cache.NewRedisAPIKeyCache(rdb)
}

func provideProviderCache(rdb redis.Cmdable) cache.ProviderCache {
	if rdb == nil {
		return nil
	}
	return cache.NewRedisProviderCache(rdb)
}

func provideRoutingRuleCache(rdb redis.Cmdable) cache.RoutingRuleCache {
	if rdb == nil {
		return nil
	}
	return cache.NewRedisRoutingRuleCache(rdb)
}

func provideModelRateCache(rdb redis.Cmdable) cache.ModelRateCache {
	if rdb == nil {
		return nil
	}
	return cache.NewRedisModelRateCache(rdb)
}
